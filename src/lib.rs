mod parse;

use std::{collections::HashMap, fmt::Display, str::FromStr};

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum LambdaExpression {
    Var(String),
    Lambda(String, Box<LambdaExpression>),
    Apply(Box<LambdaExpression>, Box<LambdaExpression>),
}

impl FromStr for LambdaExpression {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        LambdaExpression::parse(s)
    }
}

impl LambdaExpression {
    pub fn parse(input: &str) -> anyhow::Result<Self> {
        parse::parse(input)
    }

    /// return `self` `arg`
    pub fn apply(self, arg: LambdaExpression) -> LambdaExpression {
        LambdaExpression::Apply(Box::new(self), Box::new(arg))
    }

    /// return \`x`. `e`
    pub fn lambda(x: impl Into<String>, e: LambdaExpression) -> LambdaExpression {
        LambdaExpression::Lambda(x.into(), Box::new(e))
    }

    /// return `x`
    pub fn var(x: impl Into<String>) -> LambdaExpression {
        LambdaExpression::Var(x.into())
    }

    pub fn alpha_rename(&mut self, old: &str, new: &str) {
        match self {
            LambdaExpression::Var(v) if v == old => *self = LambdaExpression::Var(new.to_string()),
            LambdaExpression::Var(_) => {}
            LambdaExpression::Lambda(param, body) => {
                if param == old {
                    // Bound variable matches old; don't rename inside
                    *self = LambdaExpression::Lambda(param.clone(), body.clone())
                } else {
                    // Rename occurrences of old in the body
                    body.alpha_rename(old, new);
                }
            }
            LambdaExpression::Apply(f, x) => {
                f.alpha_rename(old, new);
                x.alpha_rename(old, new);
            }
        }
    }

    /// Substitute `val` for `x` in `self`
    /// Returns a map of variable names that were renamed to avoid capture
    pub fn substitute(
        &mut self,
        x: String,
        val: LambdaExpression,
    ) -> anyhow::Result<HashMap<String, String>> {
        println!("substitute: {} with {} in {}", x, val, self);
        let mut renamed = HashMap::new();
        self.substitute_inner(x, val, &mut renamed)?;
        // normalize rename map
        let mut renamed_normalized = HashMap::new();
        for key in renamed.keys() {
            let mut val = renamed.get(key).unwrap().clone();
            while renamed.contains_key(&val) {
                val = renamed.get(&val).unwrap().clone();
            }
            renamed_normalized.insert(key, val);
        }
        Ok(renamed)
    }
    pub fn substitute_inner(
        &mut self,
        x: String,
        val: LambdaExpression,
        rename_map: &mut HashMap<String, String>,
    ) -> anyhow::Result<()> {
        match self {
            LambdaExpression::Var(v) if *v == x => {
                *self = val;
            }
            LambdaExpression::Var(v) => {}
            LambdaExpression::Lambda(x2, e) => {
                if *x2 == x {
                    // shadowed; don't substitute
                    return Ok(());
                }
                // If x2 appears free in val, rename x2 to avoid capture
                if !val.is_fresh_name(x2) {
                    let mut fresh_x2 = x2.clone();
                    while !val.is_fresh_name(&fresh_x2) || fresh_x2 == x {
                        fresh_x2.push('\'');
                    }
                    println!("Renaming {} to {} to avoid capture", x2, fresh_x2);
                    rename_map.insert(x2.clone(), fresh_x2.clone());
                    e.alpha_rename(x2, &fresh_x2);
                    *x2 = fresh_x2;
                }
                // Now substitute inside body
                e.substitute(x, val)?;
            }
            LambdaExpression::Apply(fun, arg) => {
                fun.substitute(x.clone(), val.clone())?;
                arg.substitute(x, val)?;
            }
        }

        Ok(())
    }

    pub fn is_fresh_name(&self, x: &str) -> bool {
        match self {
            LambdaExpression::Var(v) => v != x,
            LambdaExpression::Lambda(x2, e) => x2 != x && e.is_fresh_name(x),
            LambdaExpression::Apply(fun, arg) => fun.is_fresh_name(x) && arg.is_fresh_name(x),
        }
    }
}

impl Display for LambdaExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LambdaExpression::Var(x) => write!(f, "{}", x),
            LambdaExpression::Lambda(x, e) => write!(f, "(Î»{}.{})", x, e),
            LambdaExpression::Apply(fun, x) => write!(f, "({} {})", fun, x),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum EnvValue {
    Expr(LambdaExpression),
    Clo(Closure),
}

impl TryFrom<EnvValue> for LambdaExpression {
    type Error = anyhow::Error;
    fn try_from(v: EnvValue) -> Result<Self, Self::Error> {
        match v {
            EnvValue::Expr(e) => Ok(e),
            EnvValue::Clo(c) => c.try_into(),
        }
    }
}

impl Display for EnvValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EnvValue::Expr(e) => write!(f, "{}", e),
            EnvValue::Clo(c) => write!(f, "{}", c),
        }
    }
}

impl From<StackValue> for EnvValue {
    fn from(v: StackValue) -> Self {
        match v {
            StackValue::Val(e) => EnvValue::Expr(e),
            StackValue::Clo(c) => EnvValue::Clo(c),
        }
    }
}

impl From<EnvValue> for StackValue {
    fn from(v: EnvValue) -> Self {
        match v {
            EnvValue::Expr(e) => StackValue::Val(e),
            EnvValue::Clo(c) => StackValue::Clo(c),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Env {
    var: String,
    val: EnvValue,
}

impl Display for Env {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "<{}={}>", self.var, self.val)
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Closure {
    bv: String,
    body: LambdaExpression,
    env: Vec<Env>,
}

impl Display for Closure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "<closure {},{},[", self.bv, self.body)?;
        for e in &self.env {
            write!(f, " {}", e)?;
        }
        write!(f, "]>")
    }
}

impl TryFrom<Closure> for LambdaExpression {
    type Error = anyhow::Error;
    fn try_from(c: Closure) -> Result<Self, Self::Error> {
        let mut initial = LambdaExpression::Lambda(c.bv, Box::new(c.body));
        let mut renamed = HashMap::<String, String>::new();
        // Consider env as a list of assignments
        for e in c.env.into_iter().rev() {
            let val = e.val.try_into()?;
            let var = renamed.get(&e.var).unwrap_or(&e.var);
            let renamed_thistime = initial.substitute(var.clone(), val)?;

            // Update the rename map with the new renames
            let mut renamed_new = HashMap::new();
            for (k, v) in renamed {
                let mut v = v;
                while renamed_thistime.contains_key(&v) {
                    v = renamed_thistime.get(&v).unwrap().clone();
                }
                renamed_new.insert(k, v);
            }
            renamed = renamed_new;
        }

        Ok(initial)
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Cont {
    Exp(LambdaExpression),
    AP,
}

impl Display for Cont {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Cont::Exp(e) => write!(f, "{}", e),
            Cont::AP => write!(f, "ap"),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum StackValue {
    Val(LambdaExpression),
    Clo(Closure),
}

impl Display for StackValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StackValue::Val(v) => write!(f, "{}", v),
            StackValue::Clo(c) => write!(f, "{}", c),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Dump {
    stack: Vec<StackValue>,
    env: Vec<Env>,
    control: Vec<Cont>,
    dump: Box<DumpValue>,
}

fn format_vec<T: std::fmt::Display>(vec: &[T]) -> String {
    let contents = vec
        .iter()
        .map(|item| format!("{}", item))
        .collect::<Vec<_>>()
        .join(", ");
    format!("[{}]", contents)
}
impl Display for Dump {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "<s={}, e={}, c={}, d={}>",
            format_vec(&self.stack),
            format_vec(&self.env),
            format_vec(&self.control),
            self.dump
        )
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum DumpValue {
    Dump(Dump),
    Null,
}

impl Display for DumpValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DumpValue::Dump(d) => write!(f, "{}", d),
            DumpValue::Null => write!(f, "D0"),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SECDMachine {
    stack: Vec<StackValue>,
    env: Vec<Env>,
    control: Vec<Cont>,
    dump: DumpValue,
}

impl Display for SECDMachine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "<s={:?}, e={:?}, c={:?}, d={}>",
            self.stack, self.env, self.control, self.dump
        )
    }
}

impl SECDMachine {
    pub fn new(exp: LambdaExpression) -> SECDMachine {
        SECDMachine {
            stack: Vec::new(),
            env: Vec::new(),
            control: vec![Cont::Exp(exp)],
            dump: DumpValue::Null,
        }
    }

    pub fn stack(&self) -> &Vec<StackValue> {
        &self.stack
    }

    pub fn env(&self) -> &Vec<Env> {
        &self.env
    }

    pub fn control(&self) -> &Vec<Cont> {
        &self.control
    }

    pub fn dump(&self) -> &DumpValue {
        &self.dump
    }

    pub fn lookup_env(&self, x: impl AsRef<str>) -> EnvValue {
        self.env
            .iter()
            .find_map(|e| {
                if e.var == x.as_ref() {
                    Some(e.val.clone())
                } else {
                    None
                }
            })
            .unwrap_or_else(|| EnvValue::Expr(LambdaExpression::Var(x.as_ref().to_string())))
    }

    pub fn is_done(&self) -> bool {
        self.control.is_empty() && self.dump == DumpValue::Null
    }

    pub fn get_result(&self) -> anyhow::Result<LambdaExpression> {
        if !(self.control.is_empty() && self.dump == DumpValue::Null) {
            anyhow::bail!("Not done yet");
        }
        let c = match self.stack.first().unwrap() {
            StackValue::Val(val) => return Ok(val.clone()),
            StackValue::Clo(c) => c.clone(),
        };

        c.try_into()
    }

    pub fn beta_transform(exp: LambdaExpression) -> anyhow::Result<LambdaExpression> {
        let mut secd = SECDMachine::new(exp);
        while !secd.is_done() {
            secd = secd.next()?;
        }

        secd.get_result()
    }

    pub fn beta_transform_with_log<W: std::fmt::Write>(
        exp: LambdaExpression,
        mut f: W,
    ) -> anyhow::Result<LambdaExpression> {
        let mut secd = SECDMachine::new(exp);
        fn print_pretty<W: std::fmt::Write>(machine: &SECDMachine, f: &mut W) -> std::fmt::Result {
            writeln!(f, "Stack  : {}", format_vec(machine.stack()))?;
            writeln!(f, "Env    : {}", format_vec(machine.env()))?;
            writeln!(f, "Control: {}", format_vec(machine.control()))?;
            writeln!(f, "Dump   : {}", machine.dump())?;

            Ok(())
        }
        print_pretty(&secd, &mut f)?;
        while !secd.is_done() {
            writeln!(f, "------------------------------------")?;
            print_pretty(&secd, &mut f)?;
            secd = secd.next()?;
        }
        writeln!(f, "------------------------------------")?;

        secd.get_result()
    }

    pub fn next(mut self) -> anyhow::Result<Self> {
        // 1. If ð¶ is null, suppose the current dump ð· is
        // (ðâ, ð¸â², ð¶â, ð·â²).
        // Then the current state is replaced by the state denoted by
        // (âð â¶ ðâ², ð¸â², ð¶â, ð·â²)
        let Some(hc) = self.control.pop() else {
            let DumpValue::Dump(mut d) = self.dump else {
                // no more control and dump
                return Ok(self);
            };
            if let Some(hs) = self.stack.pop() {
                d.stack.push(hs);
            }
            self.stack = d.stack;
            self.env = d.env;
            self.control = d.control;
            self.dump = *d.dump;
            return Ok(self);
        };

        // 2. If ð¶ is not null, then âð¶ is inspected, and:
        match hc {
            // (2a) If âð¶ is an identifier ð (whose value relative to ð¸ occupies the position
            // ððððð¡ðððð¸ð in ð¸), then ð is replaced by
            // ððððð¡ðððð¸ðð¸: ð
            // and ð¶ is replaced by ð¡ð¶.
            // We describe this step as follows: "Scanning ð causes ððððð¡ðððð¸ðð¸ to beloaded."
            Cont::Exp(LambdaExpression::Var(x)) => {
                let val = self.lookup_env(&x);
                self.stack.push(val.into());
            }
            // (2b) If âð¶ is a Î»-expression ð, scanning it causes the closure derived from ð¸ and ð
            // (as indicated above) to be loaded on to the stack.
            Cont::Exp(LambdaExpression::Lambda(x, e)) => {
                self.stack.push(StackValue::Clo(Closure {
                    bv: x,
                    body: *e,
                    env: self.env.clone(),
                }));
            }
            // (2c) If âð¶ is ðð, scanning it changes ð as follows:
            // âð is inspected and:
            Cont::AP => {
                let Some(hs) = self.stack.pop() else {
                    anyhow::bail!("No more stack");
                };
                match hs {
                    // (2cl) If âð is a closure, derived from ð¸â² and ðâ,
                    // then: ð is replaced by the ðð¢ðððð ð¡,
                    // ð¸ is replaced by ððððð£ð(ðð ð ðð(ðð£ðâ², 2ððð))ð¸â²,
                    // ð¶ is replaced by ð¢ððð¡ððð ð¡(ðððð¦ðâ²),
                    // ð· is replaced by (ð¡(ð¡ð), ð¸, ð¡ð¶, ð·).
                    StackValue::Clo(closure) => {
                        let Some(second_s) = self.stack.pop() else {
                            anyhow::bail!("No more stack");
                        };
                        let dumpstack = self.stack.clone();
                        let dumpenv = self.env.clone();
                        // tC
                        let dumpcontrol = self.control.clone();
                        let dumpdump = self.dump.clone();

                        self.stack.clear();

                        self.env = closure.env.clone();
                        self.env.push(Env {
                            var: closure.bv,
                            val: second_s.into(),
                        });

                        self.control.clear();
                        self.control.push(Cont::Exp(closure.body));

                        self.dump = DumpValue::Dump(Dump {
                            stack: dumpstack,
                            env: dumpenv,
                            control: dumpcontrol,
                            dump: Box::new(dumpdump),
                        });
                    }
                    // (2c2) If âð is not a closure, then scanning ðð causes ð to be replaced by
                    StackValue::Val(first) => {
                        let Some(second_s) = self.stack.pop() else {
                            anyhow::bail!("No more stack");
                        };
                        let StackValue::Val(second_s) = second_s else {
                            anyhow::bail!("Expected Val");
                        };
                        self.stack.push(StackValue::Val(LambdaExpression::Apply(
                            Box::new(first),
                            Box::new(second_s),
                        )));
                    }
                }
            }
            // (2d) If âð¶ is a combination ð, ð¶ is replaced by ððððð â¶ (ððð¡ððð â¶ (ðð â¶ ð¡ð¶))
            Cont::Exp(LambdaExpression::Apply(f, x)) => {
                self.control.push(Cont::AP);
                self.control.push(Cont::Exp(*f));
                self.control.push(Cont::Exp(*x));
            }
        }

        Ok(self)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse() {
        let lambda = "Î»x.x".parse::<LambdaExpression>().unwrap();
        assert_eq!(
            lambda,
            LambdaExpression::Lambda(
                "x".to_string(),
                Box::new(LambdaExpression::Var("x".to_string()))
            )
        );

        let lambda = "Î»x.Î»y.y".parse::<LambdaExpression>().unwrap();
        assert_eq!(
            lambda,
            LambdaExpression::Lambda(
                "x".to_string(),
                Box::new(LambdaExpression::Lambda(
                    "y".to_string(),
                    Box::new(LambdaExpression::Var("y".to_string()))
                ))
            )
        );

        let lambda = "((Î»x.x) a)".parse::<LambdaExpression>().unwrap();
        assert_eq!(
            lambda,
            LambdaExpression::Apply(
                Box::new(LambdaExpression::Lambda(
                    "x".to_string(),
                    Box::new(LambdaExpression::Var("x".to_string()))
                )),
                Box::new(LambdaExpression::Var("a".to_string()))
            )
        );

        let lambda = "(((Î»x.(Î»y. y)) ((Î»x. (x x)) (Î»x. (x x)))) ((Î»x. x) a))"
            .parse::<LambdaExpression>()
            .unwrap();
        assert_eq!(
            lambda,
            LambdaExpression::Apply(
                Box::new(LambdaExpression::Apply(
                    Box::new(LambdaExpression::Lambda(
                        "x".to_string(),
                        Box::new(LambdaExpression::Lambda(
                            "y".to_string(),
                            Box::new(LambdaExpression::Var("y".to_string()))
                        ))
                    )),
                    Box::new(LambdaExpression::Apply(
                        Box::new(LambdaExpression::Lambda(
                            "x".to_string(),
                            Box::new(LambdaExpression::Apply(
                                Box::new(LambdaExpression::Var("x".to_string())),
                                Box::new(LambdaExpression::Var("x".to_string()))
                            ))
                        )),
                        Box::new(LambdaExpression::Lambda(
                            "x".to_string(),
                            Box::new(LambdaExpression::Apply(
                                Box::new(LambdaExpression::Var("x".to_string())),
                                Box::new(LambdaExpression::Var("x".to_string()))
                            ))
                        ))
                    ))
                )),
                Box::new(LambdaExpression::Apply(
                    Box::new(LambdaExpression::Lambda(
                        "x".to_string(),
                        Box::new(LambdaExpression::Var("x".to_string()))
                    )),
                    Box::new(LambdaExpression::Var("a".to_string()))
                ))
            )
        );
    }

    #[test]
    fn test_betatransform() {
        let lambda = "Î»x.x".parse::<LambdaExpression>().unwrap();
        let result = SECDMachine::beta_transform(lambda).unwrap();
        assert_eq!(result, "Î»x.x".parse::<LambdaExpression>().unwrap());

        let lambda = "Î»x.Î»y.y".parse::<LambdaExpression>().unwrap();
        let result = SECDMachine::beta_transform(lambda).unwrap();
        assert_eq!(result, "Î»x.Î»y.y".parse::<LambdaExpression>().unwrap());

        let lambda = "((Î»x.x) a)".parse::<LambdaExpression>().unwrap();
        let result = SECDMachine::beta_transform(lambda).unwrap();
        assert_eq!(result, "a".parse::<LambdaExpression>().unwrap());

        // 1. ((Î»x.Î»y.x) a) -> Î»y.a
        {
            let lambda = "((Î»x.Î»y.x) a)".parse::<LambdaExpression>().unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            assert_eq!(result, "Î»y.a".parse::<LambdaExpression>().unwrap());
        }

        // 2. ((Î»x.Î»y.y) a) -> Î»y.y
        {
            println!("((Î»x.Î»y.y) a) -> Î»y.y");
            let lambda = "((Î»x.Î»y.y) a)".parse::<LambdaExpression>().unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            // x ã a ã§ç½®æãã¦ã y ã«ä¾å­ããªãããåã Î»y.y
            assert_eq!(result, "Î»y.y".parse::<LambdaExpression>().unwrap());
        }

        // 3. ((Î»x.x) ((Î»y.y) b)) -> b
        // (Î»y.y) b -> b ã¨ãªããããçµæã¯ (Î»x.x) b -> b
        {
            println!("((Î»x.x) ((Î»y.y) b)) -> b");
            let lambda = "((Î»x.x) ((Î»y.y) b))".parse::<LambdaExpression>().unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            assert_eq!(result, "b".parse::<LambdaExpression>().unwrap());
        }

        // 4. ((Î»x.x) ((Î»z.z z) (Î»w.w))) -> Î»w.w
        // ( (Î»z.z z) (Î»w.w) ) -> (Î»w.w)(Î»w.w) -> Î»w.w ã«ç°¡ç´ããããã
        // æçµçã« (Î»x.x)(Î»w.w) -> Î»w.w
        {
            println!("((Î»x.x) ((Î»z.z z) (Î»w.w))) -> Î»w.w");
            let lambda = "((Î»x.x) ((Î»z.z z) (Î»w.w)))"
                .parse::<LambdaExpression>()
                .unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            assert_eq!(result, "Î»w.w".parse::<LambdaExpression>().unwrap());
        }

        // 5. ((Î»x.(x a)) (Î»y.y)) -> a
        // ã¾ã (Î»x.(x a)) ã« (Î»y.y) ãé©ç¨: xã(Î»y.y)ã§ç½®æããã¨ ((Î»y.y) a) -> a
        {
            println!("((Î»x.(x a)) (Î»y.y)) -> a");
            let lambda = "((Î»x.(x a)) (Î»y.y))".parse::<LambdaExpression>().unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            assert_eq!(result, "a".parse::<LambdaExpression>().unwrap());
        }

        // 6. (((Î»x.Î»y.x) (Î»u.u)) v) -> (Î»u.u)
        // ( (Î»x.Î»y.x) (Î»u.u) ) -> Î»y.(Î»u.u)
        // ããã«ããã« v ãé©ç¨: (Î»y.(Î»u.u)) v -> Î»u.u
        {
            println!("(((Î»x.Î»y.x) (Î»u.u)) v) -> (Î»u.u)");
            let lambda = "(((Î»x.Î»y.x) (Î»u.u)) v)"
                .parse::<LambdaExpression>()
                .unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            assert_eq!(result, "Î»u.u".parse::<LambdaExpression>().unwrap());
        }

        // 7. ((Î»x.(Î»y.(y x))) a) -> Î»y.(y a)
        // x ã a ã«ç½®æ: Î»y.(y a)
        {
            println!("((Î»x.(Î»y.(y x))) a) -> Î»y.(y a)");
            let lambda = "((Î»x.(Î»y.(y x))) a)".parse::<LambdaExpression>().unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            assert_eq!(result, "Î»y.(y a)".parse::<LambdaExpression>().unwrap());
        }

        // 8. (((Î»x.x) (Î»y.(y y))) (Î»z.z)) -> Î»z.z
        // (Î»x.x) (Î»y.(y y)) -> (Î»y.(y y))
        // ((Î»y.(y y)) (Î»z.z)) -> (Î»z.z)(Î»z.z) -> Î»z.z
        {
            println!("(((Î»x.x) (Î»y.(y y))) (Î»z.z)) -> Î»z.z");
            let lambda = "(((Î»x.x) (Î»y.(y y))) (Î»z.z))"
                .parse::<LambdaExpression>()
                .unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            assert_eq!(result, "Î»z.z".parse::<LambdaExpression>().unwrap());
        }

        // 9. ((Î»x.(Î»y.y)) (Î»x.x)) -> Î»y.y
        // (Î»x.(Î»y.y)) ã« (Î»x.x) ãé©ç¨ãã¦ã Î»y.y ã«å¤ãããã
        {
            println!("((Î»x.(Î»y.y)) (Î»x.x)) -> Î»y.y");
            let lambda = "((Î»x.(Î»y.y)) (Î»x.x))".parse::<LambdaExpression>().unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            assert_eq!(result, "Î»y.y".parse::<LambdaExpression>().unwrap());
        }

        // 10. ((Î»x.(x (Î»z.z))) (Î»y.y)) -> Î»z.z
        // x ã (Î»y.y) ã§ç½®æ: ( (Î»y.y) (Î»z.z) ) -> Î»z.z
        {
            println!("((Î»x.(x (Î»z.z))) (Î»y.y)) -> Î»z.z");
            let lambda = "((Î»x.(x (Î»z.z))) (Î»y.y))"
                .parse::<LambdaExpression>()
                .unwrap();
            let result = SECDMachine::beta_transform(lambda).unwrap();
            assert_eq!(result, "Î»z.z".parse::<LambdaExpression>().unwrap());
        }
    }

    #[test]
    fn test_renamereduction() {
        let exp = "(\\x.\\y.x) y".parse::<LambdaExpression>().unwrap();
        let result = SECDMachine::beta_transform(exp).unwrap();
        assert_eq!(result, "\\y'.y".parse::<LambdaExpression>().unwrap());
        assert_eq!(
            result,
            LambdaExpression::lambda("y'", LambdaExpression::var("y"))
        );

        let exp = "((\\x.\\y.x y) (\\y.y))"
            .parse::<LambdaExpression>()
            .unwrap();
        let result = SECDMachine::beta_transform(exp).unwrap();
        let var = |x| LambdaExpression::var(x);
        assert_eq!(
            result,
            LambdaExpression::lambda(
                "y'",
                LambdaExpression::lambda("y", var("y")).apply(var("y'"))
            )
        );

        let succ = "Î»n.Î»f.Î»x.f ((n f) x)".parse::<LambdaExpression>().unwrap();
        let zero = "Î»f.Î»x.x".parse::<LambdaExpression>().unwrap();
        let one = succ.clone().apply(zero.clone());
        let one_reduced = SECDMachine::beta_transform(one.clone()).unwrap();

        assert_eq!(
            one_reduced,
            "Î»f.Î»x.f x".parse::<LambdaExpression>().unwrap()
        );
    }

    #[test]
    fn test_pred() {
        let succ = "Î»n.Î»f.Î»x.f ((n f) x)".parse::<LambdaExpression>().unwrap();
        assert_eq!(
            succ,
            LambdaExpression::Lambda(
                "n".to_string(),
                Box::new(LambdaExpression::Lambda(
                    "f".to_string(),
                    Box::new(LambdaExpression::Lambda(
                        "x".to_string(),
                        Box::new(LambdaExpression::Apply(
                            Box::new(LambdaExpression::Var("f".to_string())),
                            Box::new(LambdaExpression::Apply(
                                Box::new(LambdaExpression::Apply(
                                    Box::new(LambdaExpression::Var("n".to_string())),
                                    Box::new(LambdaExpression::Var("f".to_string()))
                                )),
                                Box::new(LambdaExpression::Var("x".to_string()))
                            ))
                        ))
                    ))
                ))
            )
        );

        let pair = "Î»x.Î»y.Î»f.f x y".parse::<LambdaExpression>().unwrap();
        assert_eq!(
            pair,
            LambdaExpression::Lambda(
                "x".to_string(),
                Box::new(LambdaExpression::Lambda(
                    "y".to_string(),
                    Box::new(LambdaExpression::Lambda(
                        "f".to_string(),
                        Box::new(LambdaExpression::Apply(
                            Box::new(LambdaExpression::Apply(
                                Box::new(LambdaExpression::Var("f".to_string())),
                                Box::new(LambdaExpression::Var("x".to_string()))
                            )),
                            Box::new(LambdaExpression::Var("y".to_string()))
                        ))
                    ))
                ))
            )
        );

        let fst = "Î»p.p (Î»x.Î»y.x)".parse::<LambdaExpression>().unwrap();
        assert_eq!(
            fst,
            LambdaExpression::Lambda(
                "p".to_string(),
                Box::new(LambdaExpression::Apply(
                    Box::new(LambdaExpression::Var("p".to_string())),
                    Box::new(LambdaExpression::Lambda(
                        "x".to_string(),
                        Box::new(LambdaExpression::Lambda(
                            "y".to_string(),
                            Box::new(LambdaExpression::Var("x".to_string()))
                        ))
                    ))
                ))
            )
        );

        let snd = "Î»p.p (Î»x.Î»y.y)".parse::<LambdaExpression>().unwrap();
        assert_eq!(
            snd,
            LambdaExpression::Lambda(
                "p".to_string(),
                Box::new(LambdaExpression::Apply(
                    Box::new(LambdaExpression::Var("p".to_string())),
                    Box::new(LambdaExpression::Lambda(
                        "x".to_string(),
                        Box::new(LambdaExpression::Lambda(
                            "y".to_string(),
                            Box::new(LambdaExpression::Var("y".to_string()))
                        ))
                    ))
                ))
            )
        );

        let p = LambdaExpression::var("p");
        let shift = LambdaExpression::lambda(
            "p",
            pair.clone()
                .apply(snd.clone().apply(p.clone()))
                .apply(succ.clone().apply(snd.apply(p))),
        );

        let zero = "Î»f.Î»x.x".parse::<LambdaExpression>().unwrap();
        let one = "Î»f.Î»x.f x".parse::<LambdaExpression>().unwrap();
        let two = "Î»f.Î»x.f (f x)".parse::<LambdaExpression>().unwrap();
        assert_eq!(
            two,
            LambdaExpression::Lambda(
                "f".to_string(),
                Box::new(LambdaExpression::Lambda(
                    "x".to_string(),
                    Box::new(LambdaExpression::Apply(
                        Box::new(LambdaExpression::Var("f".to_string())),
                        Box::new(LambdaExpression::Apply(
                            Box::new(LambdaExpression::Var("f".to_string())),
                            Box::new(LambdaExpression::Var("x".to_string()))
                        ))
                    ))
                ))
            )
        );

        // let result = SECDMachine::beta_transform(
        //     shift
        //         .clone()
        //         .apply(pair.clone().apply(zero.clone()).apply(one.clone())),
        // )
        // .unwrap();

        // assert_eq!(result, pair.clone().apply(one.clone()).apply(two.clone()));

        let pred = LambdaExpression::lambda(
            "n",
            LambdaExpression::var("n")
                .apply(shift.clone())
                .apply(pair.clone().apply(zero.clone()).apply(zero.clone())),
        );

        let reduced_pred = SECDMachine::beta_transform(pred.clone().apply(two.clone())).unwrap();
        println!("pred: {:?}", reduced_pred);
        println!("pred: {}", reduced_pred);
        println!("pred 2: {}", pred.clone().apply(two.clone()));
        println!(
            "pred 2: {}",
            SECDMachine::beta_transform(pred.clone().apply(two.clone())).unwrap()
        );

        let id = pred
            .clone()
            .apply(succ.clone().apply(LambdaExpression::var("x")));
        println!("id: {}", id);
        println!("id 2: {}", SECDMachine::beta_transform(id.clone()).unwrap());
    }
}
